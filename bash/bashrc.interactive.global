# This is the global file for non-interactive shells
#
# Settings that apply for every machine go in here.
#
# Settings that are only relevant for certain machines should go into
# ~/.bashrc.non-interactive.local or ....$HOSTNAME

# Set various shell options
shopt -s checkwinsize
#shopt -s failglob
set -o vi

# Make history more comfortable.
shopt -s cmdhist
shopt -s histappend
HISTCONTROL=ignoredups
HISTFILESIZE=10000
HISTSIZE=10000

# enable fancy completion
if [ -z "$BASH_COMPLETION" ]; then
	if [ -f /etc/bash_completion ]; then
		source /etc/bash_completion
	fi
fi

# make less more friendly for non-text input files, see lesspipe(1)
[ -x /usr/bin/lesspipe ] && eval "$(lesspipe)"

export LC_MESSAGES=C

# make less interpret color escape codes
export LESS="-FSRX"

# make grep use colors
export GREP_OPTIONS='--color=auto'
alias 'cgrep=grep --color=always'

# enable color support of ls and also add handy alias
if [ "$TERM" != "dumb" ]; then
    eval "$(dircolors -b)"
    alias ls='ls --color=auto'
fi

function truncate_start
{
    local trunc_symbol="..."
    local maxlength="$1"
    shift
    local string="$@"
    local length="${#string}"
    if [[ "$length" -gt "$maxlength" ]]; then
        local offset=$(( $length - $maxlength ))
        echo -ne "${trunc_symbol}${string:$offset:$maxlength}"
    else
        echo -ne "${string}"
    fi
}

function truncate_end
{
    local trunc_symbol="..."
    local maxlength="$1"
    shift
    local string="$@"
    local length="${#string}"
    if [[ "$length" -gt "$maxlength" ]]; then
        echo -ne "${string:0:$maxlength}${trunc_symbol}"
    else
        echo -ne "${string}"
    fi
}

function settitle
{
    local str="${@}"
    case "$TERM" in
        xterm*|rxvt*|gnome*|konsole*)
        echo -ne "\e]0;${str}\007"
        ;;
    screen*)
        echo -ne "\ek${str}\e\\"
        ;;
    esac
}

function settitle_pipe
{
    export PREV_COMMAND="${PREV_COMMAND}${@}"
    local cmd=$(truncate_end 30 "$PREV_COMMAND")
    case "$TERM" in
        xterm*|rxvt*|gnome*|konsole*)
        echo -ne "\e]0;${cmd}\007"
        ;;
    screen*)
        echo -ne "\ek${cmd}\e\\"
        ;;
    esac
    export PREV_COMMAND="${PREV_COMMAND} | "
}

function my_prompt_command
{
	local RESET="\[\e[00m\]"
	local BLACK="\[\e[00;30m\]"
	local GRAY="\[\e[01;30m\]"
	local RED="\[\e[00;31m\]"
	local LRED="\[\e[01;31m\]"
	local GREEN="\[\e[00;32m\]"
	local LGREEN="\[\e[01;32m\]"
	local BROWN="\[\e[00;33m\]"
	local YELLOW="\[\e[01;33m\]"
	local BLUE="\[\e[00;34m\]"
	local LBLUE="\[\e[01;34m\]"
	local PURPLE="\[\e[00;35m\]"
	local LPURPLE="\[\e[01;35m\]"
	local CYAN="\[\e[00;36m\]"
	local LCYAN="\[\e[01;36m\]"
	local LGRAY="\[\e[00;37m\]"
	local WHITE="\[\e[01;37m\]"

	# Get color for username
	local user=$(id -un)
	if [ $user = "root" ]; then
		local USER_COLOR=$LRED
	else
		local USER_COLOR=$GREEN
	fi
    
    # Get username
    if [[ $user != "mfischer" ]] && [[ $user != "mika" ]]; then
        local PROMPT_USER="$user"
    fi

    # Get hostname
    if [[ -n "$SSH_CONNECTION" ]]; then
        local PROMPT_HOSTNAME="$HOSTNAME"
    fi

    # Get AT
    if [[ -n "$PROMPT_USER" ]] && [[ -n "$PROMPT_HOSTNAME" ]]; then
        local PROMPT_AT="@"
    fi

    # Get COLON
    if [[ -n "$PROMPT_USER" ]] || [[ -n "$PROMPT_HOSTNAME" ]]; then
        local PROMPT_COLON=":"
    fi

	# Get exit code
	local RC=$?
	if [ $RC -ne 0 ]; then
		local PROMPT_RC="($RC)"
	else
		local PROMPT_RC=""
	fi

	# Get truncated path
	[[ "$PWD" == "$HOME" ]] && local PWD2="~"
	[[ -z "$PWD2" ]] && [[ "$PWD" == "$HOME/" ]] && local PWD2="~/"
	[[ -z "$PWD2" ]] && local PWD2="${PWD/#$HOME\//~/}"
    local PROMPT_PWD=$(truncate_start 30 "$PWD2")

	# Get git branch
	if declare -F __git_ps1 >/dev/null 2>&1; then
		local GIT_BRANCH=$(__git_ps1 "[%s]")
	else
		local GIT_BRANCH=""
	fi

	# Set prompt
	PS1="${USER_COLOR}${PROMPT_USER}${GREEN}${PROMPT_AT}${CYAN}${PROMPT_HOSTNAME}${RESET}${PROMPT_COLON}${LBLUE}${PROMPT_PWD}${LRED}${PROMPT_RC}${PURPLE}${GIT_BRANCH}${RESET}\\\$ "

	# Set xterm title and screen title
    settitle "${PROMPT_USER}${PROMPT_AT}${PROMPT_HOSTNAME}${PROMPT_COLON}${PROMPT_PWD}"

	# Write new commands to history file
	history -a

    export PREV_COMMAND=""
}

PROMPT_COMMAND='my_prompt_command'

trap 'settitle_pipe "$BASH_COMMAND"' DEBUG

# set other shell variables
export EDITOR=vim
export VISUAL=vim
export DEBFULLNAME="Mika Fischer"
export DEBEMAIL="mika.fischer@zoopnet.de"

# Aliases
alias cpptags="ctags -R --sort=yes --c++-kinds=+p --fields=+iaS --extra=+q --language-force=C++"
